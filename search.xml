<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AcWing提高课-dp-272最长公共上升子序列</title>
      <link href="/2022/06/29/acwing%E6%8F%90%E9%AB%98%E8%AF%BE/dp/272%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2022/06/29/acwing%E6%8F%90%E9%AB%98%E8%AF%BE/dp/272%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="C:\Users\feng\Desktop\blogs\source_posts\acwing提高课\dp\272最长公共上升子序列.assets\image-20220629214438758.png" alt="image-20220629214438758"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>​本题是最长上升子序列和最长公共子序列的结合。dp[i][j]表示1<del>i, 1</del>j中以b[j]为结尾的最长公共上升子序列长度。若 a[i] !&#x3D; b[j]，那么 dp[i][j] &#x3D; dp[i - 1][j]，若 a[i] &#x3D;&#x3D; b[j]，那么需要在1<del>i， 1</del>j - 1中找一个比b[j]（也就是比a[i]）小的b[k]，且最长公共上升子序列最长的状态来更新。这一点可以通过前缀最大值来得到，因为我们要找的是b[k] &lt; a[i]的最大值（k &lt; j)，因此我们在遍历到j之前一定已经遍历了k。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (u &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (u &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3005</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], b[N], dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i][j], mx + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; b[j]) mx = <span class="built_in">max</span>(mx, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">res = <span class="built_in">max</span>(res, dp[n][i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AcWing提高课-dp-187导弹防御系统</title>
      <link href="/2022/06/29/acwing%E6%8F%90%E9%AB%98%E8%AF%BE/dp/187%E5%AF%BC%E5%BC%B9%E9%98%B2%E5%BE%A1%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/06/29/acwing%E6%8F%90%E9%AB%98%E8%AF%BE/dp/187%E5%AF%BC%E5%BC%B9%E9%98%B2%E5%BE%A1%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/konbia/picgo/img/image-20220629204233099.png" alt="image-20220629204233099"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>​这题主要考虑的是对于序列中的一个数，是把它放在一个上升序列中，还是把它放在一个下降序列中。有选择性的问题无非两种解决方式，dp和dfs。</p><p>​本题状态很多，上升序列的长度，个数，每个上升序列的最大值等，且数据量很小，因此我们选择dfs。对于搜到的一个数，我们考虑将它放在已有的单调上升序列中，然后更新改单调上升序列的最大值，或新开一个上升序列。单调下降同理。设数组up[i]表示第i个上升序列的最大值，易知up数组是单调不增的，且我们一个数如果要找一个上升序列插入，一定是找一个它刚好能插入的地方（这样可以省出来小的数字给别人），因此我们只需要从前往后遍历up数组，如果能插入，就插入试试，然后就可以结束了，因为这个位置已经是最优的位置了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>​本题dfs求的是最小步数，有两种方法。1是全局最小值+剪枝，2是迭代加深。</p><p>全局最小值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (u &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (u &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n, res, a[N];</span><br><span class="line"><span class="type">int</span> up[N], down[N]; <span class="comment">//up[i]为第i个上升序列最大的值,down[i]同理</span></span><br><span class="line"><span class="comment">//k为现在枚举到第几个数，cu为上升序列的个数，du同理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> cu, <span class="type">int</span> cd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cu + cd &gt;= res) <span class="keyword">return</span> ; <span class="comment">//剪枝</span></span><br><span class="line"><span class="keyword">if</span> (k == n + <span class="number">1</span>) &#123;</span><br><span class="line">res = cu + cd;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cu; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (up[i] &lt; a[k]) &#123;</span><br><span class="line">ok = <span class="literal">true</span>; <span class="type">int</span> t = up[i];</span><br><span class="line">up[i] = a[k];</span><br><span class="line"><span class="built_in">dfs</span>(k + <span class="number">1</span>, cu, cd);</span><br><span class="line">up[i] = t;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">up[cu + <span class="number">1</span>] = a[k];</span><br><span class="line"><span class="built_in">dfs</span>(k + <span class="number">1</span>, cu + <span class="number">1</span>, cd);</span><br><span class="line">up[cu + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ok = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cd; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (down[i] &gt; a[k]) &#123;</span><br><span class="line">ok = <span class="literal">true</span>; <span class="type">int</span> t = down[i];</span><br><span class="line">down[i] = a[k];</span><br><span class="line"><span class="built_in">dfs</span>(k + <span class="number">1</span>, cu, cd);</span><br><span class="line">down[i] = t;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">down[cd + <span class="number">1</span>] = a[k];</span><br><span class="line"><span class="built_in">dfs</span>(k + <span class="number">1</span>, cu, cd + <span class="number">1</span>);</span><br><span class="line">down[cd + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n, n) &#123;</span><br><span class="line">res = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代加深：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (u &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (u &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], h;</span><br><span class="line"><span class="type">int</span> up[N], down[N]; <span class="comment">//up[i]为第i个上升序列最大的值,down[i]同理</span></span><br><span class="line"><span class="comment">//k为现在枚举到第几个数，cu为上升序列的个数，du同理</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> cu, <span class="type">int</span> cd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cu + cd &gt; h) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//大于深度就走</span></span><br><span class="line"><span class="keyword">if</span> (k == n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cu; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (up[i] &lt; a[k]) &#123;</span><br><span class="line">ok = <span class="literal">true</span>; <span class="type">int</span> t = up[i];</span><br><span class="line">up[i] = a[k];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(k + <span class="number">1</span>, cu, cd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">up[i] = t;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">up[cu + <span class="number">1</span>] = a[k];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(k + <span class="number">1</span>, cu + <span class="number">1</span>, cd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">up[cu + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ok = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cd; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (down[i] &gt; a[k]) &#123;</span><br><span class="line">ok = <span class="literal">true</span>; <span class="type">int</span> t = down[i];</span><br><span class="line">down[i] = a[k];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(k + <span class="number">1</span>, cu, cd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">down[i] = t;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">down[cd + <span class="number">1</span>] = a[k];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(k + <span class="number">1</span>, cu, cd + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">down[cd + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n, n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line">h = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)) h++;</span><br><span class="line">cout &lt;&lt; h &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AcWing提高课-dp-1027方块取数</title>
      <link href="/2022/06/28/acwing%E6%8F%90%E9%AB%98%E8%AF%BE/dp/1027%E6%96%B9%E5%9D%97%E5%8F%96%E6%95%B0/"/>
      <url>/2022/06/28/acwing%E6%8F%90%E9%AB%98%E8%AF%BE/dp/1027%E6%96%B9%E5%9D%97%E5%8F%96%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/konbia/picgo/img/image-20220628201038991.png" alt="image-20220628201038991"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>​本题最重要的点在于如何处理路径重复的问题，同时进行状态转移。主要有两种思考方式。一、分两次走，第一次走时做标记；二、同时走。第一种方法难以想出状态表示方法，只能够贪心选取。第二种方法可行，如果两个人同时从A向B走，并让他们的步长相等，便可以得到状态的表示——dp[k][i1][i2]为两个人走了k步时，第一个人在i1行，第二个人在i2行时可以拿到的数的最大值。</p><p>​我们先枚举步长，便可以保证步长比当前短的状态已经得到。接着正常的状态转移，剩下的就是当两个点重合时我们只有取一遍权值，就能很好的处理路线有重复的情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (u &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (u &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line">LL dp[N * N][N][N], a[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line"><span class="keyword">while</span> (x || y || c) &#123;</span><br><span class="line">a[x][y] = c;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= n * <span class="number">2</span>; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i1 = <span class="number">1</span>; i1 &lt;= n; i1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i2 = <span class="number">1</span>; i2 &lt;= n; i2++) &#123;</span><br><span class="line">    <span class="type">int</span> j1 = k - i1, j2 = k - i2;</span><br><span class="line">    <span class="keyword">if</span> (j1 &lt; <span class="number">1</span> || j2 &lt; <span class="number">1</span> || j1 &gt; n || j2 &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">LL t = a[i1][k - i1]; <span class="keyword">if</span> (i1 != i2) t += a[i2][k - i2];</span><br><span class="line">dp[k][i1][i2] = <span class="built_in">max</span>(dp[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>], dp[k - <span class="number">1</span>][i1][i2]);</span><br><span class="line">dp[k][i1][i2] = <span class="built_in">max</span>(dp[k][i1][i2], dp[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2]);</span><br><span class="line">dp[k][i1][i2] = <span class="built_in">max</span>(dp[k][i1][i2], dp[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>]);</span><br><span class="line">dp[k][i1][i2] += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n * <span class="number">2</span>][n][n] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><a href="https://www.acwing.com/activity/content/problem/content/1259/">AcWing 1017 怪盗基德</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客的创建</title>
      <link href="/2022/06/28/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2022/06/28/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>hello</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
